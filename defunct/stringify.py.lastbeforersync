# #!/usr/bin/env python
# import os
# import fnmatch
# import sys
# import logging
#
# logging.basicConfig(level=logging.DEBUG)
# logger = logging.getLogger(__name__)
#
#
# def parse_arguments():
#     if len(sys.argv) < 2:
#         print("Usage: python stringify.py <directory> [patterns...]")
#         sys.exit(1)
#
#     directory = sys.argv[1]
#     patterns = sys.argv[2:]
#     return directory, patterns
#
#
# def is_binary(file_path):
#     try:
#         with open(file_path, 'rb') as file:
#             return b'\0' in file.read(1024)
#     except IOError:
#         return False
#
#
# def match_pattern(path, pattern):
#     logger.debug(f"Matching path: {path} against pattern: {pattern}")
#     logger.debug(f"Path components: {path.split(os.sep)}")
#     logger.debug(f"Pattern components: {pattern.split(os.sep)}")
#     if pattern.startswith('/'):
#         result = fnmatch.fnmatch('/' + path, pattern)
#     elif '**' in pattern:
#         parts = pattern.split('**')
#         result = path.startswith(parts[0]) and path.endswith(parts[-1]) and all(part in path for part in parts[1:-1])
#     else:
#         result = fnmatch.fnmatch(path, pattern) or fnmatch.fnmatch(os.path.basename(path), pattern)
#     logger.debug(f"Match result: {result}")
#     return result
#
#
# def build_file_list(directory, patterns):
#     logger.debug(f"Building file list for directory: {directory}")
#     logger.debug(f"Patterns: {patterns}")
#
#     all_files = set()
#     for root, dirs, files in os.walk(directory):
#         for file in files:
#             all_files.add(os.path.relpath(os.path.join(root, file), directory))
#
#     logger.debug(f"All files: {all_files}")
#
#     include_only_mode = any(not p.startswith('-') for p in patterns)
#     logger.debug(f"Include-only mode: {include_only_mode}")
#
#     result = set()
#     excluded = set()
#
#     logger.debug(f"Patterns is {patterns}")
#     for pattern in patterns:
#         logger.debug(f"Processing pattern: {pattern}")
#         is_exclude = pattern.startswith('-')
#         logger.debug(f"Is exclude: {is_exclude}")
#         pattern = pattern[1:] if is_exclude else pattern
#         logger.debug(f"Pattern after stripping '-' if present: {pattern}")
#
#         matched = set(f for f in all_files if match_pattern(f, pattern))
#         logger.debug(f"Matched files for pattern {pattern}: {matched}")
#
#         if is_exclude:
#             excluded.update(matched)
#             # Exclude contents of matched directories
#             for path in matched:
#                 if os.path.isdir(os.path.join(directory, path)):
#                     excluded.update(f for f in all_files if f.startswith(path + os.sep))
#         else:
#             result.update(matched)
#             for path in all_files:
#                 if match_pattern(path, pattern):
#                     if is_exclude:
#                         excluded.add(path)
#                         logger.debug(f"Excluded based on pattern {pattern}: {path}")
#                     else:
#                         result.add(path)
#                         logger.debug(f"Included based on pattern {pattern}: {path}")
#
#     logger.debug(f"Files after pattern matching - Included: {result}, Excluded: {excluded}")
#
#     if include_only_mode:
#         final_result = result - excluded
#     else:
#         final_result = all_files - excluded
#         final_result.update(result)
#
#     logger.debug(f"Final result after mode application: {final_result}")
#     return sorted(final_result)
#
#
# def gather_code(directory, file_list):
#     result = ""
#     for file_path in file_list:
#         full_path = os.path.join(directory, file_path)
#         if os.path.isfile(full_path):
#             try:
#                 if is_binary(full_path):
#                     result += f'--- {file_path} ---\n[Binary file]\n\n'
#                 else:
#                     with open(full_path, 'r', encoding='utf-8', errors='ignore') as file_content:
#                         file_data = file_content.read()
#                         result += f'--- {file_path} ---\n{file_data}\n\n'
#             except Exception as e:
#                 logger.error(f"Error reading {file_path}: {e}")
#     return result
#
#
# def main():
#     directory, patterns = parse_arguments()
#     directory = directory.rstrip('/')
#
#     file_list = build_file_list(directory, patterns)
#     result = gather_code(directory, file_list)
#     print(result)
#
#
# if __name__ == '__main__':
#     main()
